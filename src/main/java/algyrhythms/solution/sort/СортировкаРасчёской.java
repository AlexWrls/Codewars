package algyrhythms.solution.sort;

import org.junit.Assert;
import org.junit.Test;

/**
 * <h3>Сортировка расчёской</h3>
 * Простой и эффективный алгоритм сортировки на основе сравнения, который является улучшением алгоритма пузырьковой сортировки.
 * <p>
 * Алгоритм:
 * <p>
 * Шаг 1: Инициализируем gap. Обычно он равен длине массива, деленной на 1,247.
 * <p>
 * Шаг 2: Сравниваем элементы, расположенные на текущем промежутке. Если элементы не в правильном порядке,
 * поменяйте их местами. Продолжайте сравнивать и менять местами элементы с одинаковым зазором по всему массиву.
 * <p>
 * Шаг 3: Каждый раз по окончанию  прохода через весь массив с текущим значением gap, мы уменьшаем его
 * на фиксированный коэффициент 1,247. Повторяем процесс сравнения и замены с новым, меньшим зазором.
 * <p>
 * Шаг 4: Когда gap = 1, выполните последний проход по массиву. Наш массив отсортирован.
 * <p>
 * Сложность: O(n*log(n))
 */
public class СортировкаРасчёской {

    @Test
    public void test() {
        int[] arr = new int[]{0, 5, 2, 4, 1, 3, 8, 7, 9, 6};
        Assert.assertArrayEquals(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, sort(arr));
    }

    public static int[] sort(int[] arr) {
        int gap = arr.length;
        boolean swapped = true;
        while (gap > 1 || swapped) {
            gap = (gap > 1) ? (int) (gap / 1.247330950103979) : 1;
            int i = 0;
            swapped = false;
            while (i + gap < arr.length) {
                if (arr[i] > (arr[i + gap])) {
                    int temp = arr[i];
                    arr[i] = arr[i + gap];
                    arr[i + gap] = temp;
                    swapped = true;
                }
                i++;
            }
        }
        return arr;
    }


}
