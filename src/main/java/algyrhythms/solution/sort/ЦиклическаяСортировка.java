package algyrhythms.solution.sort;

import org.junit.Assert;
import org.junit.Test;

/**
 * <h3>Циклическая сортировка</h3>
 * <p>
 * Алгоритм сортировки, который полезен при сортировке массивов, содержащих элементы с небольшим диапазоном значений.
 * <p>
 * Алгоритм:<p>
 * Шаг 1: Инициализируйте переменную pos значением 0.<p>
 * Шаг 2: Для каждого элемента массива сравните его со всеми остальными элементами справа от него.
 * Если есть какие-либо элементы, которые меньше текущего элемента, увеличьте pos.<p>
 * Шаг 3: Если pos по-прежнему равен 0 после сравнения первого элемента со всеми остальными элементами,
 * перейдите к следующему элементу и повторите шаг 2.<p>
 * Шаг 4: Как только будет найден меньший элемент, замените текущий элемент первым элементом в его цикле.
 * Затем цикл продолжается до тех пор, пока текущий элемент не вернется в исходное положение.<p>
 * <p>
 * Повторяйте шаги 3–5, пока не будут завершены все циклы. Теперь массив отсортирован.
 * <p>
 * Сложность: O(n^2)
 */
public class ЦиклическаяСортировка {

    @Test
    public void test() {
        int[] arr = new int[]{10, 5, 2, 4, 1, 3, 8, 7, 9, 6};
        Assert.assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, sort(arr));
    }

    public static int[] sort(int[] arr) {
        // кол-во записей в памяти
        int writes = 0;

        // перемещаем элементы массива и помещаем их в on
        // нужное место
        for (int cycle_start = 0; cycle_start <= arr.length - 2; cycle_start++) {
            // инициализировать элемент в качестве начальной точки
            int item = arr[cycle_start];

            // Находим позицию, в которую мы помещаем элемент. Мы в основном
            // подсчитываем все меньшие элементы справа от элемента.
            int pos = cycle_start;
            for (int i = cycle_start + 1; i < arr.length; i++)
                if (arr[i] < item)
                    pos++;

            // Если элемент уже находится в правильном положении
            if (pos == cycle_start)
                continue;

            // игнорировать все повторяющиеся элементы
            while (item == arr[pos])
                pos += 1;

            // установите элемент в нужное положение
            if (pos != cycle_start) {
                int temp = item;
                item = arr[pos];
                arr[pos] = temp;
                writes++;
            }

            // Провеять оставшуюся часть цикла
            while (pos != cycle_start) {
                pos = cycle_start;

                // Находим позицию, в которую мы помещаем элемент
                for (int i = cycle_start + 1; i < arr.length; i++)
                    if (arr[i] < item)
                        pos += 1;

                // игнорировать все повторяющиеся элементы
                while (item == arr[pos])
                    pos += 1;

                // установите элемент в нужное положение
                if (item != arr[pos]) {
                    int temp = item;
                    item = arr[pos];
                    arr[pos] = temp;
                    writes++;
                }
            }
        }
        return arr;
    }

}
