package algyrhythms.solution.sort;

import org.junit.Assert;
import org.junit.Test;

/**
 * <h3>Сортировка выбором</h3>
 * <p>
 * Это простой и интуитивно понятный алгоритм сортировки.
 * Он неоднократно находит самый маленький (или самый большой) элемент из неотсортированной части массива и заменяет
 * его первым неотсортированным элементом.
 * <p>
 * Алгоритм:
 * <p>
 * 1. Начинаем с того, что весь входной массив считается неотсортированным.<p>
 * 2. Перебираем неотсортированную часть массива, чтобы найти минимальный (или максимальный) элемент.<p>
 * 3. Как только минимальный (или максимальный) элемент определен, он заменяется первым элементом в несортированной части.<p>
 * 4. Продолжаем этот процесс, уменьшая размер неотсортированной части на один элемент на каждой итерации, пока весь<p>
 * массив не будет отсортирован.<p>
 * Сложность алгоритма:<p>
 * В лучшем случаи:  O(n^2)<p>
 * В cреднем: O(n^2)<p>
 * В худшем: O(n^2)<p>
 */
public class СортировкаВыбором {

    @Test
    public void test() {
        int[] arr = new int[]{10, 5, 2, 4, 1, 3, 8, 7, 9, 6};
        Assert.assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, sort(arr));
    }

    public static int[] sort(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] > arr[j]) {
                    int tmp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = tmp;
                }
            }
        }
        return arr;
    }

}
