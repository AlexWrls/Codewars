package algyrhythms.solution.sort;

import org.junit.Assert;
import org.junit.Test;

/**
 * <h3>Быстрая сортировка</h3>
 * <p>
 * Это алгоритм сортировки, который эффективно сортирует элементы, разделяя входные данные на более мелкие подзадачи.
 * Он работает путем выбора элемента «pivot» из входных данных и разделения других элементов на два подмассива:
 * элементы меньше, чем «pivot», и элементы, превышающие «pivot». Он рекурсивно сортирует два подмассива.
 * <p>
 * Алгоритм:<p>
 * 1. Выбор «pivot» из входного массива. (Его выбор может существенно повлиять на производительность алгоритма.
 * Это может быть: первый, последний или случайный элемент).<p>
 * 2. Разделение элементов массива так, чтобы все элементы меньше «pivot» находились перед ним, а все элементы выше «pivot» — после нее.<p>
 * 3. Рекурсивное примените алгоритма быстрой сортировки к подмассиву элементов, меньших опорного, и к подмассиву элементов, превышающих опорный.<p>
 * 4. Продолжайте этот процесс, пока весь массив не будет отсортирован.<p>
 * <p>
 * Сложность алгоритма:<p>
 * В лучшем случаи:  O(n logn)<p>
 * В cреднем: O(n logn)<p>
 * В худшем: O(n^2)<p>
 */
public class БыстраяСортировка {

    @Test
    public void test() {
        int[] arr = new int[]{10, 5, 2, 4, 1, 3, 8, 7, 9, 6};
        Assert.assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, sort(arr));
    }

    public static int[] sort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
        return arr;
    }

    private static void quickSort(int[] arr, int left, int right) {
        int i = left;
        int j = right;
//     сводный номер, к примеру середина
        int pivot = arr[left + (right - left) / 2];

        while (i <= j) {
//          Уменьшать вправо, пока не найдем элемент, меньший, чем pivot
            while (arr[i] < pivot) {
                i++;
            }
//            Увеличивать влево, пока не найдем элемент, больший, чем pivot
            while (arr[j] > pivot) {
                j--;
            }
            if (i <= j) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                //переместить указатель в следующую позицию с обеих сторон
                i++;
                j--;
            }
        }
//        вызываем метод quickSort() рекурсивно
        if (left < j)
            quickSort(arr, left, j);
        if (i < right)
            quickSort(arr, i, right);
    }

}
